

##################
#Model prototypes#
##################


#' Get the radius of maximum wind speed according to Willoughby model
#'
#' @param vmax Maximum wind speed generated
#' @param lat Latitude where `vmax` has occured
#'
#' @return radius of maximum wind speed (km)
get_RMW = function(vmax,
                   lat) {
  return (46.4 * exp(-0.0155 * vmax + 0.0169 * abs(lat)))
}


#' Compute wind values according to the Willoughby model
#'
#' @param vmax Maximum wind speed generated
#' @param lat Latitude of the eye of the storm
#' @param r Distance to the center of the storm where the value must be computed
#' @param rmw Radius of maximum wind speed. Default value is set to NULL
#' @return wind value according to the Willoughby model at distance `r` to the
#'  center of the storm located in latitude `lat`

Willoughby_profile = function(vmax,
                             lat,
                             r,
                             rmw = NULL) {
  if (is.null(rmw)) {
    RMW = get_RMW(vmax, lat)
  } else{
    RMW = rmw
  }
  RMW = rep(RMW, length(r))
  if (r >= RMW) {
    XX1 = 287.6 - 1.942 * vmax + 7.799 * log(RMW) + 1.819 * abs(lat)
    XX2 = 25
    AA = 0.5913 + 0.0029 * vmax - 0.1361 * log(RMW) - 0.0042 * abs(lat)
    Vr = vmax * ((1 - AA) * exp(-abs((r - RMW) / XX1)) + AA * exp(-abs(r -
                                                                          RMW) / XX2))
  } else{
    nn = 2.1340 + 0.0077 * vmax - 0.4522 * log(RMW) - 0.0038 * abs(lat)
    Vr = vmax * abs((r / RMW) ^ nn)
  }


  return(Vr)
}

#Vectorize version of the above model
Willoughby <- Vectorize(Willoughby_profile, vectorize.args = "r")



#' Compute wind values according to the Holland 80 model
#'
#' @param r Distance to the center of the storm where the value must be computed
#' @param rmw Radius of maximum wind speed
#' @param vmax Maximum wind speed generated
#' @param pc Pressure at the center of the storm
#' @param poci Pressure at the Outermost Closed Isobar
#' @param lat Latitude of the storm (eye)
#' @return wind value according to the Holland 80 model at distance `r` to the
#'  center of the storm
Holland80_profile = function(r,
                            rmw,
                            vmax,
                            pc,
                            poci,
                            lat){

  rho = 1.15  #air densiy
  f = 2 * 7.29 *10**(-5) * sin(lat) #Coriolis parameter
  b = rho * exp(1) * vmax**2 / (poci - pc)

  Vr = sqrt(b/rho * (rmw/r)**b * (poci - pc)*exp(-(rmw/r)**b) + (r*f/2)**2) - r*f/2


  return(Vr)

}

#Vectorize version of the above model
Holland80 <- Vectorize(Holland80_profile, vectorize.args = "r")


#' Compute wind values according to the Boose 01 model
#'
#' @param r Distance to the center of the storm where the value must be computed
#' @param t Clockwise angle between forward motion of hurricane and radial line to P
#' @param rmw Radius of maximum wind speed. Default value is set to NULL
#' @param landfall Minimum distance to land over next 3 hours (=0 means landfall)
#' @param vmax Maximum wind speed generated
#' @param Vh forward speed of storm
#' @param pc Pressure at the center of the storm
#' @param poci Pressure at the Outermost Closed Isobar
#' @return wind value according to the Boose 01 at distance `r` to the
#'  center of the storm
Boose01_profile = function(r,
                          t,
                          rmw,
                          landfall,
                          vmax,
                          Vh,
                          pc,
                          poci){

  if(landfall > 0){
    f = 1
  }else{
    f = 0.8
  }

  S = 1
  b = 1.15 * exp(1) * vmax**2 / (poci - pc)

  Vr = f *(vmax - S*(1 - sin(t))*Vh/2) * sqrt((rmw/r)**b *exp(1 - (rmw/r)**b))

 return(Vr)

}

#Vectorize version of the above model
Boose01 <- Vectorize(Boose01_profile, vectorize.args = c("r","t"))



#' Rasterizing various products among Maximum sustained Wind Speed and PDI,
#' associated with the each storm
#'
#' @param sts Set of storm generated by `getStorms` we are interested in
#' @param product Characters that represent the product we would like to compute,
#' currently among `MSW` and `PDI`.
#' @param method Cyclonic model used to compute product. Default value is set to
#' `Willoughby`.
#' @param asymmetry Character that indicates which asymmetry to use in the computations.
#' Default value is set to "None".
#' @param use_rmw Logical, whether or not using the Radius of maximum wind speed
#' from the database. Default value is set to TRUE
#' @param points ...
#' @param space_res Space resolution (km) of the incoming raster products.
#' Default value is set to 10km.
#' @param time_res Time discretization (in hours) to compute the products.
#' Default value is set to 1h.
#' @param verbose Logical, whether or not the function must be verbose. Default
#' value is set to `FALSE`
#' @param focus_loi Logical, whether or not the computations must only take
#' place within the loi. Default
#' value is set to `TRUE`
#'
#' @return A raster stack gathering all the results. Names of the layer are
#' nameOfTheStorm_product
#' @export
stormBehaviour = function(sts,
                          product = "MSW",
                          method = "Willoughby",
                          asymmetry = "None",
                          use_rmw = TRUE,
                          points = NULL,
                          space_res = 10,
                          time_res = 1,
                          verbose = FALSE,
                          focus_loi = TRUE) {
  #Check sts input
  stopifnot("no data found" = !missing(sts))

  #Check product input
  stopifnot("Invalid product" = product %in% c("MSW", "PDI", "Category"))

  #Check method input
  stopifnot("Invalid method input" = method %in% c("Willoughby", "Holland80"))
  stopifnot("Only one method must be chosen" = length(method) == 1)

  #Check asymmetry input
  stopifnot("Invalid asymmetry input" = asymmetry %in% c("None", "V1", "V2"))
  stopifnot("Only one asymmetry must be chosen" = length(asymmetry) == 1)

  #Check use_rmw input
  stopifnot("use_rmw must be logical" = identical(class(use_rmw), "logical"))

  #Check points input
  if(!is.null(points))
    stopifnot("points must be data.frame" = identical(class(points), "data.frame"))

  #Check space_res input
  stopifnot("space_res must be numeric" = identical(class(space_res), "numeric"))
  stopifnot("space_res must be as integer" = is_wholenumber(space_res))
  stopifnot("space_res must be positif" = space_res > 0)

  #Check time_res input
  stopifnot("time_res must be numeric" = identical(class(time_res), "numeric"))
  stopifnot("invalid time_res" = time_res %in% c(1, 0.75, 0.5, 0.25))

  #Check verbose input
  stopifnot("verbose must be logical" = identical(class(verbose), "logical"))

  #Check focus_loi input
  stopifnot("focus_loi must be logical" = identical(class(focus_loi), "logical"))
  initial_floi = focus_loi



  if(is.null(points)){
    #Generate the raster template
    xmin = sf::st_bbox(sts@spatial.loi.buffer)$xmin
    xmax = sf::st_bbox(sts@spatial.loi.buffer)$xmax
    ymin = sf::st_bbox(sts@spatial.loi.buffer)$ymin
    ymax = sf::st_bbox(sts@spatial.loi.buffer)$ymax
    e <- terra::ext(xmin, xmax, ymin, ymax)

    ras = terra::rast(
      xmin = xmin,
      xmax = xmax,
      ymin = ymin,
      ymax = ymax,
      vals = NA
    )
    #Projection in Mercator
    ras = terra::project(ras, "EPSG:3857")
    #Resample in new resolution in Mercator
    ras.template = ras
    terra::res(ras.template) = c(space_res * 1000, space_res * 1000)
    ras.template <- terra::resample(ras, ras.template)
    #Reprojection in lon/lat
    ras.template = terra::project(ras.template, "EPSG:4326")

    #Handling time line crossing
    if(terra::ext(ras.template)$xmin < 0){
      ras.template = terra::rast(resolution = terra::res(ras.template), extent = e)
    }

    final.stack = c()
  }



  s = 1

  for (st in sts@data) {
    if (focus_loi) {
      #Use observations within the loi for the computations
      ind = seq(st@obs[1], st@obs[st@numobs], 1)

      if(is.null(points)){
        #Handling indices and offset (2 outside of loi at entry and exit)
        if (st@obs[1] >= 3) {
          ind = c(st@obs[1] - 2, st@obs[1] - 1, ind)
        } else if (st@obs[1] == 2) {
          ind = c(st@obs[1] - 1, ind)
        }

        if (st@obs[st@numobs] <= st@numobs.all - 2) {
          ind = c(ind, st@obs[st@numobs] + 1, st@obs[st@numobs] + 2)
        } else if (st@obs[st@numobs] == st@numobs.all - 1) {
          ind = c(ind, st@obs[st@numobs] + 1)
        }
      }
    } else{
      #Use all observations available for the computations
      ind = seq(1, st@numobs.all, 1)
    }


    #Get all variables and remove NAs
    dat = data.frame(
      lon = st@obs.all$lon[ind],
      lat = st@obs.all$lat[ind],
      msw = st@obs.all$wind[ind],
      rmw = st@obs.all$rmw[ind],
      roci = st@obs.all$roci[ind],
      pc = st@obs.all$pres[ind],
      poci = st@obs.all$poci[ind],
      landfall = st@obs.all$landfall[ind]
    )
    dat = dat[stats::complete.cases(dat), ]
    dat$storm.speed = NA
    dat$vx.deg = NA
    dat$vy.deg = NA

    #Compute speed of storm (m/s)
    for(i in 1:(dim(dat)[1]-1)){
      dat$storm.speed[i] = terra::distance(
        x = cbind(dat$lon[i],dat$lat[i]),
        y = cbind(dat$lon[i+1],dat$lat[i+1]),
        lonlat = T
      ) * (0.001 / 3) / 3.6

      dat$vx.deg[i] = (dat$lon[i + 1] - dat$lon[i]) / 3
      dat$vy.deg[i] = (dat$lat[i + 1] - dat$lat[i]) / 3

    }




    if(is.null(points)){

      #Interpolated time step dt, default value dt = 4 --> 1h
      dt = 1 + (1 / time_res * 3) # + 1 for the limit values

      #Compute number of steps
      last.obs = dim(dat)[1]
      nb.steps = dt * (last.obs - 1) - (last.obs - 2)
      step = 1


      if (verbose) {
        cat("Computing",
            product,
            "raster using",
            method,
            "model (time_res:",
            time_res,
            "h, space_ras:",
            space_res,
            "km, asymmetry:",
            asymmetry,
            ", use_rmw:",
            use_rmw,
            ") for",
            st@name,
            "(",
            s,
            "/",
            sts@nb.storms,
            ")\n")
        pb = utils::txtProgressBar(min = 1,
                                   max = last.obs - 1,
                                   style = 3)
      }



      aux.stack = c()
      #For every general 3H time step j
      for (j in 1:(last.obs - 1)) {

        lon = rep(NA, dt)
        lon[1] = dat$lon[j]
        lon[dt] = dat$lon[j + 1]
        lon = zoo::na.approx(lon)

        lat = rep(NA, dt)
        lat[1] = dat$lat[j]
        lat[dt] = dat$lat[j + 1]
        lat = zoo::na.approx(lat)

        msw = rep(NA, dt)
        msw[1] = dat$msw[j]
        msw[dt] = dat$msw[j + 1]
        msw = zoo::na.approx(msw)

        pc = rep(NA, dt)
        pc[1] = dat$pc[j]
        pc[dt] = dat$pc[j + 1]
        pc = zoo::na.approx(pc)

        poci = rep(NA, dt)
        poci[1] = dat$poci[j]
        poci[dt] = dat$poci[j + 1]
        poci = zoo::na.approx(poci)

        rmw = rep(NA, dt)
        rmw[1] = dat$rmw[j]
        rmw[dt] = dat$rmw[j + 1]
        rmw = zoo::na.approx(rmw)

        vx.deg = dat$vx.deg[j]
        vy.deg = dat$vy.deg[j]
        storm.speed = dat$storm.speed[j]

        #For every interpolated time steps dt
        for (i in 1:dt) {
          if (i == dt & j != last.obs - 1)
            break #avoid redondance

          raster.msw = ras.template

          #Compute distances to the eye of the storm for x and y axes
          x = (terra::crds(raster.msw, na.rm = FALSE)[, 1] - lon[i])
          y = (terra::crds(raster.msw, na.rm = FALSE)[, 2] - lat[i])
          #Compute distances to the eye of the storm in m
          dist.m = terra::distance(
            x = terra::crds(raster.msw, na.rm = FALSE)[, ],
            y = cbind(lon[i], lat[i]),
            lonlat = T
          )

          if(asymmetry == "V2"){
            msw[i] = msw[i] - storm.speed
          }

          #Compute sustained winds according to the input model
          if (method == "Willoughby") {
            if(!use_rmw){
              rmw[i] = NULL
            }

            terra::values(raster.msw) = Willoughby(
              vmax = msw[i],
              lat = lat[i],
              r = dist.m * 0.001,
              rmw = rmw[i]
            )

          }else if (method == "Holland80") {

            terra::values(raster.msw) = Holland80(
              r = dist.m * 0.001,
              rmw = rmw[i],
              vmax = msw[i],
              pc = pc[i] * 100,
              poci = poci[i] * 100,
              lat = lat[i]
            )
          }

          #Add asymmetry
          if (asymmetry == "V1") {
            #Boose version
            #South Hemisphere only, t is counterclockwise
            raster.t = ras.template
            terra::values(raster.t) = (atan2(vy.deg,vx.deg)) - atan2(y,x) + pi
            terra::values(raster.msw) = terra::values(raster.msw) - (1 - sin(terra::values(raster.t)))*(storm.speed/3.6)/2

          } else if(asymmetry == "V2"){
            raster.t = ras.template
            terra::values(raster.t) = acos((y * vx.deg - x * vy.deg) / (sqrt(vx.deg**2 + vy.deg**2) * sqrt(x**2 + y**2)))
            terra::values(raster.msw) = terra::values(raster.msw) + cos(terra::values(raster.t))* storm.speed
          }

          if (product == "MSW") {
            aux.stack = c(aux.stack, raster.msw)
          }else if (product == "PDI"){
            Cd = ras.template
            ind1 = terra::values(raster.msw) <= 31.5
            ind2 = terra::values(raster.msw) > 31.5
            terra::values(Cd)[ind1] = (0.8 + 0.06 * terra::values(raster.msw)[ind1]) * 0.001
            terra::values(Cd)[ind2] = (0.55 + 2.97 * terra::values(raster.msw)[ind2] /31.5
                                       - 1.49 * (terra::values(raster.msw)[ind2] / 31.5) ** 2) * 0.001
            terra::values(Cd)[terra::values(raster.msw) <= 18] = 0
            rho = 0.001
            #Raising to power 3
            raster.msw = raster.msw ** 3
            #Apply both rho and surface drag coefficient
            raster.msw = raster.msw * rho * Cd
            aux.stack = c(aux.stack, raster.msw)
          }else if (product == "Category"){
            r = ras.template
            ind = which(terra::values(raster.msw) >= 32 &
                          terra::values(raster.msw) <= 42)
            r[ind] = 1
            aux.stack = c(aux.stack, r)
            r = ras.template
            ind = which(terra::values(raster.msw) >= 43 &
                          terra::values(raster.msw) <= 49)
            r[ind] = 1
            aux.stack = c(aux.stack, r)
            r = ras.template
            ind = which(terra::values(raster.msw) >= 50 &
                          terra::values(raster.msw) <= 57)
            r[ind] = 1
            aux.stack = c(aux.stack, r)
            r = ras.template
            ind = which(terra::values(raster.msw) >= 58 &
                          terra::values(raster.msw) <= 69)
            r[ind] = 1
            aux.stack = c(aux.stack, r)
            r = ras.template
            ind = which(terra::values(raster.msw) >= 70)
            r[ind] = 1
            aux.stack = c(aux.stack, r)
          }

          step = step + 1
        }
        if (verbose)
          utils::setTxtProgressBar(pb, j)
      }

      if (verbose)
        close(pb)


      aux.stack = terra::rast(aux.stack)
      product.raster = ras.template

      if (product == "MSW") {
        #Compute msw raster
        product.raster = max(aux.stack, na.rm = T)
        #Apply focal function twice to smooth results
        product.raster = terra::focal(
          product.raster,
          w = matrix(1, 3, 3),
          max,
          na.rm = T,
          pad = T
        )
        product.raster = terra::focal(
          product.raster,
          w = matrix(1, 3, 3),
          mean,
          na.rm = T,
          pad = T
        )
        names(product.raster) = paste0(st@name, "_", product)
        final.stack = c(final.stack, product.raster)


      } else if (product == "PDI") {
        #Integrating over the whole track
        product.raster = sum(aux.stack, na.rm = T) * time_res
        #Apply focal function to smooth results
        product.raster = terra::focal(
          product.raster,
          w = matrix(1, 3, 3),
          sum,
          na.rm = T,
          pad = T
        )
        names(product.raster) = paste0(st@name, "_", product)
        final.stack = c(final.stack, product.raster)

      } else if (product == "Category") {
        #For each category in SSHS
        ras_c = c()
        for (i in c(1, 2, 3, 4, 0)) {
          ind = which(seq(1, terra::nlyr(aux.stack)) %% 5 == i)
          #Integrating over the whole track
          product.raster = sum(terra::subset(aux.stack, ind), na.rm = T) * time_res
          #Apply focal function to smooth results
          product.raster = terra::focal(
            product.raster,
            w = matrix(1, 3, 3),
            sum,
            na.rm = T,
            pad = T
          )
          if (i == 0)
            i = 5
          names(product.raster) = paste0(st@name, "_", product, i)
          final.stack = c(final.stack, product.raster)
          ras_c = c(ras_c, product.raster)
        }

        #Add all categories
        ras_c = terra::rast(ras_c)
        ras_c = sum(ras_c, na.rm = T)
        names(ras_c) = paste0(st@name, "_Categories")
        final.stack = c(final.stack, ras_c)
      }

    }else{

      #Compute distances from the eye of storm for every observations x, and
      #every points y
      dist.m = terra::distance(
        x = cbind(dat$lon,dat$lat),
        y = cbind(points$lon, points$lat),
        lonlat = T
      )

      res = c()
      #For each point
      for(i in 1:dim(points)[1]){

        #Compute distance in deg between eye of storm and point P
        x = points$lon[i] - dat$lon
        y = points$lat[i] - dat$lat

        if(asymmetry == "V2"){
          msw = dat$msw[i] - dat$storm.speed[i]
        }else{
          msw = dat$msw[i]
        }

        if (method == "Willoughby") {
          if(!use_rmw){
            rmw = NULL
          }else{
            rmw = dat$rmw[i]
          }

           X = Willoughby(
            vmax = msw,
            lat = dat$lat[i],
            r = dist.m[,i] * 0.001,
            rmw = rmw
          )

        }else if (method == "Holland80") {

          X = Holland80(
            r = dist.m[,i] * 0.001,
            rmw = rmw,
            vmax = msw,
            pc = dat$pc[i] * 100,
            poci = dat$poci[i] * 100,
            lat = dat$lat[i]
          )
        }

        if (asymmetry == "V1") {
          #Boose version
          #South Hemisphere only, t is counterclockwise
          t = (atan2(dat$vy.deg[i],dat$vx.deg[i])) - atan2(y,x) + pi
          X = X - (1 - sin(t)) * dat$storm.speed[i]/2

        } else if(asymmetry == "V2"){
          t = acos((y * dat$vx.deg[i] - x * dat$vy.deg[i]) / (sqrt(dat$vx.deg[i]**2 + dat$vy.deg[i]**2) * sqrt(x**2 + y**2)))
          X = X + cos(t) * dat$storm.speed[i]
        }

        if (product == "PDI") {
          Cd = X
          ind1 = which(Cd <= 31.5)
          ind2 = which(Cd > 31.5)
          Cd[ind1] = (0.8 + 0.06 * X[ind1]) * 0.001
          Cd[ind2] = (0.55 + 2.97 * X[ind2] / 31.5 - 1.49 * (X[ind2] / 31.5) ** 2) * 0.001
          Cd[X <= 18] = 0
          rho = 0.001

          #Raising to power 3
          X = X ** 3

          #Apply both rho and surface drag coefficient
          X = X * rho * Cd

          #Integrating over the whole track
          X = sum(X, na.rm = T) * 3

        }else if (product == "Category") {
          ind1 = which(X >= 32 & X <= 42)
          ind2 = which(X >= 43 & X <= 49)
          ind3 = which(X >= 50 & X <= 57)
          ind4 = which(X >= 58 & X <= 69)
          ind5 = which(X >= 70)

          X1 = rep(0,length(X))
          X1[ind1] = 1
          X1 = sum(X1, na.rm = T) * 3

          X2 = rep(0,length(X))
          X2[ind2] = 1
          X2 = sum(X2, na.rm = T) * 3

          X3 = rep(0,length(X))
          X3[ind3] = 1
          X3 = sum(X3, na.rm = T) * 3

          X4 = rep(0,length(X))
          X4[ind4] = 1
          X4 = sum(X4, na.rm = T) * 3

          X5 = rep(0,length(X))
          X5[ind5] = 1
          X5 = sum(X5, na.rm = T) * 3

          X = c(X1,X2,X3,X4,X5)
        }

        res = cbind(res,X)

      }

    }
    s = s + 1
  }

  if(is.null(points)){
    final.stack = terra::rast(final.stack)
    if (initial_floi) {
      #Mask the stack to fit loi buffer
      v = terra::vect(sts@spatial.loi.buffer)
      m = terra::rasterize(v, product.raster)
      final.stack = terra::mask(final.stack, m)
    }

    return(final.stack)

  }else{

    if(product == "MSW"){
      res = data.frame(res, row.names = ind)
    }else if(product == "PDI"){
      res = data.frame(res,row.names = "PDI")
    }else{
      res = data.frame(res,row.names = c("Cat.1", "Cat.2", "Cat.3", "Cat.4", "Cat.5"))
    }

    colnames(res) =paste0("(",points$lon,",",points$lat,")")
    return(res)
  }

}
