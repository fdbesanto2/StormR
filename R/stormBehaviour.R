




#' Get the radius of maximum wind speed according to Willoughby model
#'
#' @param w_max Maximum wind speed generated
#' @param lat Latitude where `w_max` has occured
#'
#' @return radius of maximum wind speed (km)
get_RMW = function(w_max, lat) {
  return (46.4 * exp(-0.0155 * w_max + 0.0169 * abs(lat)))
}


#' Compute wind values according to the Willoughby model
#'
#' @param w_max Maximum wind speed generated
#' @param lat Latitude where `w_max` has occured
#' @param r Distance to the center of the storm where the value must be computed
#' @param rmw Radius of maximum wind speed. Default value is set to NULL
#' @return wind value according to the Willoughby model at distance `r` to the
#'  center of the storm located in latitude `lat`

Willoughby_cyc_profil = function(w_max, lat, r, rmw = NULL) {
  if (is.null(rmw)) {
    RMW = get_RMW(w_max, lat)
  } else{
    RMW = rmw
  }
  RMW = rep(RMW, length(r))
  if (r >= RMW) {
    XX1 = 287.6 - 1.942 * w_max + 7.799 * log(RMW) + 1.819 * abs(lat)
    XX2 = 25
    AA = 0.5913 + 0.0029 * w_max - 0.1361 * log(RMW) - 0.0042 * abs(lat)
    Wr = w_max * ((1 - AA) * exp(-abs((r - RMW) / XX1)) + AA * exp(-abs(r -
                                                                          RMW) / XX2))
  } else{
    nn = 2.1340 + 0.0077 * w_max - 0.4522 * log(RMW) - 0.0038 * abs(lat)
    Wr = w_max * abs((r / RMW) ^ nn)
  }


  return(Wr)
}

#Vectorize version of the above model
Willoughby <- Vectorize(Willoughby_cyc_profil, vectorize.args = "r")



#' Rasterizing various products among Maximum sustained Wind Speed and PDI,
#' associated with the each storm
#'
#' @param sts Set of storm generated by `getStorms` we are interested in
#' @param product Characters that represent the product we would like to compute,
#' currently among `MSW` and `PDI`.
#' @param method Cyclonic model used to compute product. Default value is set to
#' `willoughby`.
#' @param asymmetry Logical, whether or not adding asymmetry to the analytic model.
#' Default value is set to TRUE
#' @param use_rmw Logical, whether or not using the Radius of maximum wind speed
#' from the database. Default value is set to TRUE
#' @param space_res Space resolution (km) of the incoming raster products.
#' Default value is set to 10km.
#' @param time_res Time discretization (in hours) to compute the products.
#' Default value is set to 1h.
#' @param verbose Logical, whether or not the function must be verbose. Default
#' value is set to `FALSE`
#' @param focus_loi Logical, whether or not the computations must only take
#' place within the loi. Default
#' value is set to `TRUE`
#'
#' @return A raster stack gathering all the results. Names of the layer are
#' nameOfTheStorm_product
#' @export
stormBehaviour = function(sts,
                          product = "MSW",
                          method = "willoughby",
                          asymmetry = TRUE,
                          use_rmw = TRUE,
                          space_res = 10,
                          time_res = 1,
                          verbose = FALSE,
                          focus_loi = TRUE) {
  #Check sts input
  stopifnot("no data found" = !missing(sts))

  #Check product input
  stopifnot("Invalid product" = product %in% c("MSW", "PDI", "Category"))

  #Check method input
  stopifnot("Invalid method" = method %in% c("willoughby"))

  #Check space_res input
  stopifnot("space_res must be numeric" = identical(class(space_res), "numeric"))
  stopifnot("space_res must be as integer" = is_wholenumber(space_res))
  stopifnot("space_res must be positif" = space_res > 0)

  #Check time_res input
  stopifnot("time_res must be numeric" = identical(class(time_res), "numeric"))
  stopifnot("invalid time_res" = time_res %in% c(1, 0.75, 0.5, 0.25))

  #Check verbose input
  stopifnot("verbose must be logical" = identical(class(verbose), "logical"))

  #Check focus_loi input
  stopifnot("focus_loi must be logical" = identical(class(focus_loi), "logical"))
  if (product == "PDI") {
    focus_loi = FALSE
    warning("focus_loi ignored and set to FALSE")
  }


  xmin = sf::st_bbox(sts@spatial.loi.buffer)$xmin
  xmax = sf::st_bbox(sts@spatial.loi.buffer)$xmax
  ymin = sf::st_bbox(sts@spatial.loi.buffer)$ymin
  ymax = sf::st_bbox(sts@spatial.loi.buffer)$ymax
  e <- terra::ext(xmin, xmax, ymin, ymax)

  ras = terra::rast(
    xmin = xmin,
    xmax = xmax,
    ymin = ymin,
    ymax = ymax,
    vals = NA
  )
  #Projection in Mercator
  ras = terra::project(ras, "EPSG:3857")
  #Resample in new resolution in Mercator
  ras.template = ras
  terra::res(ras.template) = space_res * 1000
  ras.template <- terra::resample(ras, ras.template)
  #Reprojection in lon/lat
  ras.template = terra::project(ras.template, "EPSG:4326")
  #Handling time line crossing
  ras.template = terra::crop(ras.template, e)
  ras.template = terra::extend(ras.template, e)


  final.stack = c()
  s = 1

  for (st in sts@data) {
    if (focus_loi) {
      #Use observations within the loi for the computations
      ind = seq(st@obs[1], st@obs[st@numobs], 1)

      #Handling indices and offset
      if (st@obs[1] >= 3) {
        ind = c(st@obs[1] - 2, st@obs[1] - 1, ind)
      } else if (st@obs[1] == 2) {
        ind = c(st@obs[1] - 1, ind)
      }

      if (st@obs[st@numobs] <= st@numobs.all - 2) {
        ind = c(ind, st@obs[st@numobs] + 1, st@obs[st@numobs] + 2)
      } else if (st@obs[st@numobs] == st@numobs.all - 1) {
        ind = c(ind, st@obs[st@numobs] + 1)
      }
    } else{
      #Use all observations available for the computations
      ind = seq(1, st@numobs.all, 1)
    }


    #Get all variables and remove NAs
    dat = data.frame(
      lon = st@obs.all$lon[ind],
      lat = st@obs.all$lat[ind],
      msw = zoo::na.approx(st@obs.all$wind[ind], rule = 2),
      rmw = st@obs.all$rmw[ind]
    )
    dat = dat[stats::complete.cases(dat), ]


    #Interpolated time step dt, default value dt = 4 --> 1h
    dt = 1 + (1 / time_res * 3) # + 1 for the limit values

    #Compute number of steps
    last.obs = dim(dat)[1]
    nb.steps = dt * (last.obs - 1) - (last.obs - 2)
    n = 1


    if (verbose) {
      cat("Computing",
          product,
          "raster using",
          method,
          "model (time_res:",
          time_res,
          "h, space_ras:",
          space_res,
          "km, asymmety:",
          asymmetry,
          ", use_rmw:",
          use_rmw,
          ") for",
          st@name,
          "(",
          s,
          "/",
          sts@nb.storms,
          ")\n")
      pb = utils::txtProgressBar(min = 1,
                                 max = last.obs - 1,
                                 style = 3)
    }

    aux.stack = c()
    #For every general 3H time step j
    for (j in 1:(last.obs - 1)) {

      longitude = rep(NA, dt)
      longitude[1] = dat$lon[j]
      longitude[dt] = dat$lon[j + 1]
      longitude = zoo::na.approx(longitude)

      latitude = rep(NA, dt)
      latitude[1] = dat$lat[j]
      latitude[dt] = dat$lat[j + 1]
      latitude = zoo::na.approx(latitude)

      wind = rep(NA, dt)
      wind[1] = dat$msw[j]
      wind[dt] = dat$msw[j + 1]
      wind = zoo::na.approx(wind)

      if (use_rmw) {
        radius = rep(NA, dt)
        radius[1] = dat$rmw[j]
        radius[dt] = dat$rmw[j + 1]
        radius = zoo::na.approx(radius)
      } else{
        radius = NULL
      }

      #Compute velocity of storm (deg/h)
      vx.deg = (dat$lon[j + 1] - dat$lon[j]) / 3
      vy.deg = (dat$lat[j + 1] - dat$lat[j]) / 3
      N = sqrt(vx.deg ** 2 + vy.deg ** 2)

      #(km/h)
      vx.km = vx.deg * space_res / terra::res(ras.template)[1]
      vy.km = vy.deg * space_res / terra::res(ras.template)[2]
      Nv = sqrt(vx.km ** 2 + vy.km ** 2)


      #For every interpolated time steps dt
      for (i in 1:dt) {
        if (i == dt & j != last.obs - 1)
          break #avoid redondance

        raster.msw = ras.template
        #distances to the eye of the storm in km
        dist.km = terra::distance(
          x = terra::crds(raster.msw, na.rm = FALSE)[, ],
          y = cbind(longitude[i], latitude[i]),
          lonlat = T
        ) * 0.001

        if (method == "willoughby") {
          #Compute willoughby raster
          terra::values(raster.msw) = Willoughby(
            w_max = wind[i],
            lat = latitude[i],
            r = dist.km,
            rmw = radius[i]
          )
        }

        #Add asymmetry
        if (asymmetry) {
          x = (terra::crds(raster.msw, na.rm = FALSE)[, 1] - longitude[i])
          y = (terra::crds(raster.msw, na.rm = FALSE)[, 2] - latitude[i])
          r = sqrt(x ** 2 + y ** 2)
          raster.theta = ras.template
          terra::values(raster.theta) = acos((y * vx.deg+-x * vy.deg) /
                                               (N * r))
          terra::values(raster.msw) = terra::values(raster.msw) +
            cos(terra::values(raster.theta)) * (Nv / 3.6)
        }

        if (product == "Category") {
          r = ras.template
          ind = which(terra::values(raster.msw) >= 32 &
                        terra::values(raster.msw) <= 42)
          r[ind] = 1
          aux.stack = c(aux.stack, r)
          r = ras.template
          ind = which(terra::values(raster.msw) >= 43 &
                        terra::values(raster.msw) <= 49)
          r[ind] = 1
          aux.stack = c(aux.stack, r)
          r = ras.template
          ind = which(terra::values(raster.msw) >= 50 &
                        terra::values(raster.msw) <= 57)
          r[ind] = 1
          aux.stack = c(aux.stack, r)
          r = ras.template
          ind = which(terra::values(raster.msw) >= 58 &
                        terra::values(raster.msw) <= 69)
          r[ind] = 1
          aux.stack = c(aux.stack, r)
          r = ras.template
          ind = which(terra::values(raster.msw) >= 70)
          r[ind] = 1
          aux.stack = c(aux.stack, r)
        } else{
          aux.stack = c(aux.stack, raster.msw)
        }


        if (product == "PDI") {
          Cd = ras.template
          ind1 = terra::values(raster.msw) <= 31.5
          ind2 = terra::values(raster.msw) > 31.5
          terra::values(Cd)[ind1] = (0.8 + 0.06 * terra::values(raster.msw)[ind1]) * 0.001
          terra::values(Cd)[ind2] = (0.55 + 2.97 * (terra::values(raster.msw)[ind2] /31.5)
                                     - 1.49 * (terra::values(raster.msw)[ind2] / 31.5) ** 2) * 0.001
        }

        n = n + 1
      }
      if (verbose)
        utils::setTxtProgressBar(pb, j)
    }

    if (verbose)
      close(pb)

    aux.stack = terra::rast(aux.stack)
    product.raster = ras.template

    if (product == "MSW") {
      #Compute msw raster
      product.raster = max(aux.stack, na.rm = T)
      #Apply focal function twice to smooth results
      product.raster = terra::focal(
        product.raster,
        w = matrix(1, 3, 3),
        max,
        na.rm = T,
        pad = T
      )
      product.raster = terra::focal(
        product.raster,
        w = matrix(1, 3, 3),
        mean,
        na.rm = T,
        pad = T
      )
      names(product.raster) = paste0(st@name, "_", product)
      final.stack = c(final.stack, product.raster)

    } else if (product == "PDI") {
      #Raising to power 3
      aux.stack = aux.stack ^ 3
      #Apply both rho and surface drag coefficient
      rho = 0.001
      aux.stack = aux.stack * rho * Cd
      #Integrating over the whole track
      product.raster = sum(aux.stack, na.rm = T) * time_res
      #Apply focal function to smooth results
      product.raster = terra::focal(
        product.raster,
        w = matrix(1, 3, 3),
        sum,
        na.rm = T,
        pad = T
      )
      names(product.raster) = paste0(st@name, "_", product)
      final.stack = c(final.stack, product.raster)

    } else if (product == "Category") {
      #For each category in SSHS
      ras_c = c()
      for (i in c(1, 2, 3, 4, 0)) {
        ind = which(seq(1, terra::nlyr(aux.stack)) %% 5 == i)
        #Integrating over the whole track
        product.raster = sum(terra::subset(aux.stack, ind), na.rm = T) * time_res
        #Apply focal function to smooth results
        product.raster = terra::focal(
          product.raster,
          w = matrix(1, 3, 3),
          sum,
          na.rm = T,
          pad = T
        )
        if (i == 0)
          i = 5
        names(product.raster) = paste0(st@name, "_", product, i)
        final.stack = c(final.stack, product.raster)
        ras_c = c(ras_c, product.raster)


      }
      #Add all categories
      ras_c = terra::rast(ras_c)
      ras_c = sum(ras_c, na.rm = T)
      names(ras_c) = paste0(st@name, "_Categories")
      final.stack = c(final.stack, ras_c)
    }

    final.stack = terra::rast(final.stack)

    if (focus_loi) {
      #Mask the stack to fit loi buffer
      v = terra::vect(sts@spatial.loi.buffer)
      m = terra::rasterize(v, product.raster)
      final.stack = terra::mask(final.stack, m)
    }

    s = s + 1
  }

  return(final.stack)
}
