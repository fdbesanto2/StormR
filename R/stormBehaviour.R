



#' Get the radius of maximum wind speed according to Willoughby model
#'
#' @param w_max Maximum wind speed generated
#' @param lat Latitude where `w_max` has occured
#'
#' @return radius of maximum wind speed (km)
get_RMW = function(w_max,lat){
  return (46.4 * exp(-0.0155*w_max + 0.0169*abs(lat)))
}


#' Compute wind values according to the Willoughby model
#'
#' @param w_max Maximum wind speed generated
#' @param lat Latitude where `w_max` has occured
#' @param r Distance to the center of the storm where the value must be computed
#'
#' @return wind value according to the Willoughby model at distance `r` to the
#'  center of the storm located in latitude `lat`

Willoughby_cyc_profil = function(w_max, lat, r){

  RMW = get_RMW(w_max,lat)
  RMW = rep(RMW,length(r))
  if(r >= RMW){
    XX1 = 287.6 - 1.942 * w_max + 7.799 * log(RMW) +1.819 * abs(lat)
    XX2 = 25
    AA = 0.5913 + 0.0029 * w_max - 0.1361 * log(RMW) -0.0042 * abs(lat)
    Wr = w_max * ((1-AA) * exp(-abs((r-RMW)/XX1)) + AA * exp(-abs(r-RMW)/XX2))
  }else{
    nn = 2.1340 + 0.0077 * w_max - 0.4522 * log(RMW) - 0.0038 * abs(lat)
    Wr = w_max*abs((r/RMW)^nn)
  }


  return(Wr)
}

#Vectorize version of the above model
Willoughby <- Vectorize(Willoughby_cyc_profil, vectorize.args = "r")



#' Rasterizing various products among Maximum sustained Wind Speed and PDI,
#' associated with the each storm
#'
#' @param sts Set of storm generated by `getStorms` we are interested in
#' @param product Characters that represent the product we would like to compute,
#' currently among `MSW` and `PDI`.
#' @param method Cyclonic model used to compute product. Default value is set to
#' `willoughby`.
#' @param space_res Space resolution (km) of the incoming raster products.
#' Default value is set to 10km.
#' @param time_res Time discretization (in hours) to compute the products.
#' Default value is set to 1h.
#' @param verbose Logical, whether or not the function must be verbose. Default
#' value is set to `FALSE`
#' @param focus_loi Logical, whether or not the computations must only take
#' place within the loi. Default
#' value is set to `TRUE`
#'
#' @return A raster stack gathering all the results. Names of the layer are
#' nameOfTheStorm_product
#' @export
stormBehaviour = function(sts,
                          product = "MSW",
                          method = "willoughby",
                          space_res = 10,
                          time_res = 1,
                          verbose = FALSE,
                          focus_loi = TRUE){

  #Check sts input
  stopifnot("no data found" = !missing(sts))

  #Check product input
  stopifnot("Invalid product" = product %in% c("MSW", "PDI", "Duration"))

  #Check method input
  stopifnot("Invalid method" = method %in% c("willoughby"))

  #Check space_res input
  stopifnot("space_res must be numeric" = identical(class(space_res),"numeric"))
  stopifnot("space_res must be as integer" = is_wholenumber(space_res))
  stopifnot("space_res must be positif" = space_res > 0)

  #Check time_res input
  stopifnot("time_res must be numeric" = identical(class(time_res),"numeric"))
  stopifnot("time_res must be as integer" = is_wholenumber(time_res))
  stopifnot("time_res must be positif" = time_res > 0)

  #Check verbose input
  stopifnot("verbose must be logical" = identical(class(verbose),"logical"))

  #Check focus_loi input
  stopifnot("focus_loi must be logical" = identical(class(focus_loi),"logical"))
  if(product == "PDI"){
    focus_loi = FALSE
    warning("focus_loi ignored and set to FALSE")
  }


  xmin = sf::st_bbox(sts@spatial.loi.buffer)$xmin
  xmax = sf::st_bbox(sts@spatial.loi.buffer)$xmax
  ymin = sf::st_bbox(sts@spatial.loi.buffer)$ymin
  ymax = sf::st_bbox(sts@spatial.loi.buffer)$ymax
  e <- terra::ext(xmin, xmax, ymin, ymax)

  ras = terra::rast(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax, vals=NA)
  #Projection in Mercator
  ras = terra::project(ras,"EPSG:3857")
  #Resample in new resolution in Mercator
  ras.template = ras
  terra::res(ras.template) = space_res*1000
  ras.template <- terra::resample(ras,ras.template)
  #Reprojection in lon/lat
  ras.template = terra::project(ras.template,"EPSG:4326")
  #Handling time line crossing
  ras.template = terra::crop(ras.template, e)
  ras.template = terra::extend(ras.template,e)


  product.stack = c()
  s = 1

  for(st in sts@data){

    product.raster = ras.template

    if(all(!is.na(st@obs.all$wind)))
      warning("NA values detected")


    if(focus_loi){
      #Handling indices and offset
      ind = seq(st@obs[1],st@obs[st@numobs],1)

      if(st@obs[1] >= 3){
        ind = c(st@obs[1] - 2,st@obs[1] - 1, ind)
      }else if(st@obs[1] == 2){
        ind = c(st@obs[1] - 1, ind)
      }

      if(st@obs[st@numobs] <= st@numobs.all - 2){
        ind = c(ind, st@obs[st@numobs] + 1, st@obs[st@numobs] + 2)
      }else if(st@obs[st@numobs] == st@numobs.all - 1){
        ind = c(ind, st@obs[st@numobs] + 1)
      }
    }else{
      ind = seq(1,st@numobs.all,1)
    }

    lon = st@obs.all$lon[ind]
    lat = st@obs.all$lat[ind]
    last.obs = length(ind)
    wmo.msw = zoo::na.approx(st@obs.all$wind[ind],rule = 2)


    nb.steps = 4*(last.obs-1) - (last.obs-2)
    n = 1
    aux.stack = c()


    if(verbose)
      cat(st@name,"-",product,"(",s,"/",sts@nb.storms,")\n")



    pb = utils::txtProgressBar(min = 1,
                        max = last.obs-1,
                        style = 3)
    #For every general 3H time step j
    for(j in 1:(last.obs-1)){
        lon.a = lon[j]
        lon.b = lon[j+1]
        lat.a = lat[j]
        lat.b = lat[j+1]
        msw.a = wmo.msw[j]
        msw.b = wmo.msw[j+1]
        if(is.na(msw.b)){
          msw.b = msw.a#correction bug
        }

        #Interpolated time step dt, default value dt = 1*3 --> 1h
        dt = 1 + (time_res * 3) #+ 1 for the limit values
        longitude = rep(NA,dt);
        longitude[1] = lon.a;
        longitude[dt] = lon.b;
        longitude = zoo::na.approx(longitude)

        latitude = rep(NA,dt)
        latitude[1] = lat.a
        latitude[dt] = lat.b
        latitude = zoo::na.approx(latitude)

        msw = rep(NA,dt)
        msw[1] = msw.a
        msw[dt] = msw.b
        msw = zoo::na.approx(msw)

        #For every interpolated time steps dt
        for(i in 1:dt){

          if(i == dt & j != last.obs-1)
            break #avoid redondance

          x = longitude[i]
          y = latitude[i]
          w = msw[i]

          raster.aux = product.raster
          # distances to the eye of the storm in km
          dist.km = terra::distance(x = terra::crds(raster.aux, na.rm = FALSE)[,],
                                    y = cbind(x,y),
                                    lonlat = T) * 0.001

          if(method == "willoughby"){
            #Compute willoughby raster
            terra::values(raster.aux) = Willoughby(w_max = w,
                                                   lat = y,
                                                   r = dist.km)
          }

          if(product == "Duration"){
            r = raster.aux
            terra::values(r) = NA
            ind = which(terra::values(raster.aux) >= 32 & terra::values(raster.aux) <= 42)
            r[ind] = 1
            ind = which(terra::values(raster.aux) >= 43 & terra::values(raster.aux) <= 49)
            r[ind] = 2
            ind = which(terra::values(raster.aux) >= 50 & terra::values(raster.aux) <= 57)
            r[ind] = 3
            ind = which(terra::values(raster.aux) >= 58 & terra::values(raster.aux) <= 69)
            r[ind] = 4
            ind = which(terra::values(raster.aux) >= 70)
            r[ind] = 5
            raster.aux = r
          }


          aux.stack = c(aux.stack,raster.aux)
          n = n+1
        }
        if(verbose)
          utils::setTxtProgressBar(pb, j)
    }
    close(pb)

    aux.stack = terra::rast(aux.stack)
    if(product == "MSW"){
      #Compute msw raster
      product.raster = max(aux.stack, na.rm = T)
      #Apply focal function twice to smooth results
      product.raster = terra::focal(product.raster, w=matrix(1,3,3), max, na.rm = T, pad=T)
      product.raster = terra::focal(product.raster, w=matrix(1,3,3), mean, na.rm = T, pad=T)
    }else if(product == "PDI"){
      #Raising to power 3
      aux.stack = aux.stack^3
      #Apply surface drag coefficient
      aux.stack = aux.stack * 0.001
      #Integrating over the whole track
      product.raster = sum(aux.stack, na.rm = T)
      #Apply focal function to smooth results
      product.raster = terra::focal(product.raster, w=matrix(1,3,3), sum, na.rm = T, pad=T)
    }else if(product == "Duration"){
      #Compute duration raster
      product.raster = sum(aux.stack, na.rm = T)
      #Apply focal function to smooth results
      product.raster = terra::focal(product.raster, w=matrix(1,3,3), sum, na.rm = T, pad=T)
    }

    if(focus_loi){
      v = terra::vect(sts@spatial.loi.buffer)
      m = terra::rasterize(v,product.raster)
      product.raster = terra::mask(product.raster,m)
    }

    names(product.raster) = paste0(st@name,"_",product)
    product.stack = c(product.stack, product.raster)

    s = s+1
  }

  return(terra::rast(product.stack))
}





