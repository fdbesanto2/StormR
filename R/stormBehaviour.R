



#' Get the radius of maximum wind speed according to Willoughby model
#'
#' @param w_max Maximum wind speed generated
#' @param lat Latitude where `w_max` has occured
#'
#' @return radius of maximum wind speed (km)
get_RMW = function(w_max,lat){
  return (46.4 * exp(-0.0155*w_max + 0.0169*abs(lat)))
}


#' Compute wind values according to the Willoughby model
#'
#' @param w_max Maximum wind speed generated
#' @param lat Latitude where `w_max` has occured
#' @param r Distance to the center of the storm where the value must be computed
#'
#' @return wind value according to the Willoughby model at distance `r` to the
#'  center of the storm located in latitude `lat`

Willoughby_cyc_profil = function(w_max, lat, r){

  RMW = get_RMW(w_max,lat)
  RMW = rep(RMW,length(r))
  if(r >= RMW){
    XX1 = 287.6 - 1.942 * w_max + 7.799 * log(RMW) +1.819 * abs(lat)
    XX2 = 25
    AA = 0.5913 + 0.0029 * w_max - 0.1361 * log(RMW) -0.0042 * abs(lat)
    Wr = w_max * ((1-AA) * exp(-abs((r-RMW)/XX1)) + AA * exp(-abs(r-RMW)/XX2))
  }else{
    nn = 2.1340 + 0.0077 * w_max - 0.4522 * log(RMW) - 0.0038 * abs(lat)
    Wr = w_max*abs((r/RMW)^nn)
  }


  return(Wr)
}

#Vectorize version of the above model
Willoughby <- Vectorize(Willoughby_cyc_profil, vectorize.args = "r")



#' Rasterizing various products among Maximum sustained Wind Speed and PDI,
#' associated with the each storm
#'
#' @param sts Set of storm generated by `getStorms` we are interested in
#' @param product Characters that represent the product we would like to compute,
#' currently among `MSW` and `PDI`.
#' @param method Cyclonic model used to compute product. Default value is set to
#' `willoughby`.
#' @param space_res Space resolution (km) of the incoming raster products.
#' Default value is set to 10km.
#' @param time_res Time discretization (in hours) to compute the products.
#' Default value is set to 1h.
#' @param verbose Logical, whether or not the function must be verbose. Default
#' value is set to `FALSE`
#'
#' @return A raster stack gathering all the results. Names of the layer are
#' nameOfTheStorm_product
#' @export
stormBehaviour = function(sts,
                          product = "MSW",
                          method = "willoughby",
                          space_res = 10,
                          time_res = 1,
                          verbose = FALSE){




  xmin = sf::st_bbox(sts@spatial.loi.buffer)$xmin
  xmax = sf::st_bbox(sts@spatial.loi.buffer)$xmax
  ymin = sf::st_bbox(sts@spatial.loi.buffer)$ymin
  ymax = sf::st_bbox(sts@spatial.loi.buffer)$ymax

  ras = terra::rast(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax, vals=NA)
  #Projection in Mercator
  ras = terra::project(ras,"EPSG:3857")
  #Resample in new resolution in Mercator
  ras.template = ras
  terra::res(ras.template) = space_res*1000
  ras.template <- terra::resample(ras,ras.template)
  #Reprojection in lon/lat
  ras.template = terra::project(ras.template,"EPSG:4326")


  product.stack = c()

  for(st in sts@data){

    product.raster = ras.template

    if(all(!is.na(st@obs$Nadi_wind)))
      warning("NA values detected")


    lon = st@obs$lon
    lat = st@obs$lat
    last.obs = st@numobs
    wmo.msw = zoo::na.approx(st@obs$Nadi_wind,rule = 2)




    nb.steps = 4*(last.obs-1) - (last.obs-2)
    n = 1
    aux.stack = c()
    #For every general 3H time step j
    for(j in 1:(last.obs-1)){
      lon.a = lon[j]
      lon.b = lon[j+1]
      lat.a = lat[j]
      lat.b = lat[j+1]
      msw.a = wmo.msw[j]
      msw.b = wmo.msw[j+1]
      if(is.na(msw.b)){
        msw.b = msw.a#correction bug
      }

      #Interpolated time step dt, default value dt = 1*3 --> 1h
      dt = 1 + (time_res * 3) #+ 1 for the limit values
      longitude = rep(NA,dt);
      longitude[1] = lon.a;
      longitude[dt] = lon.b;
      longitude = zoo::na.approx(longitude)

      latitude = rep(NA,dt)
      latitude[1] = lat.a
      latitude[dt] = lat.b
      latitude = zoo::na.approx(latitude)

      msw = rep(NA,dt)
      msw[1] = msw.a
      msw[dt] = msw.b
      msw = zoo::na.approx(msw)

      #For every interpolated time steps dt
      for(i in 1:dt){

        if(i == dt & j != last.obs-1)
          break #avoid redondance

        x = longitude[i]
        y = latitude[i]
        w = msw[i]

        if(verbose)
          cat("Computing rasters ...  ",n/nb.steps *100,"%\n")
          #cat("Computing rasters ...  ",x," ",y," ",w," ",n/nb.steps *100,"%\n")


        raster.aux = product.raster
        # distances to the eye of the storm in km
        dist.km = terra::distance(x = terra::crds(raster.aux, na.rm = FALSE)[,],
                                  y = cbind(x,y),
                                  lonlat = T) * 0.001


        if(product == "MSW"){
          if(method == "willoughby"){
           #Compute willoughby raster
           terra::values(raster.aux) = Willoughby(w_max = w,
                                                   lat = y,
                                                   r = dist.km)
          }
        }

        aux.stack = c(aux.stack,raster.aux)
        n = n+1
      }
    }

    aux.stack = terra::rast(aux.stack)
    if(product == "MSW"){
      #Compute msw raster
      product.raster = max(aux.stack, na.rm = T);
      #apply focal function twice to smooth results
      product.raster = terra::focal(product.raster, w=matrix(1,3,3), max, na.rm = T, pad=T)
      product.raster = terra::focal(product.raster, w=matrix(1,3,3), mean, na.rm = T, pad=T)
    }
    names(product.raster) = paste0(st@name,"_",product)
    product.stack = c(product.stack, product.raster)
  }

  return(terra::rast(product.stack))
}





