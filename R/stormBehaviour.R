

##################
#Model prototypes#
##################


#' Get the radius of maximum wind speed according to Willoughby model
#'
#' @param w_max Maximum wind speed generated
#' @param lat Latitude where `w_max` has occured
#'
#' @return radius of maximum wind speed (km)
get_RMW = function(w_max, lat) {
  return (46.4 * exp(-0.0155 * w_max + 0.0169 * abs(lat)))
}


#' Compute wind values according to the Willoughby model
#'
#' @param w_max Maximum wind speed generated
#' @param lat Latitude of the eye of the storm
#' @param r Distance to the center of the storm where the value must be computed
#' @param rmw Radius of maximum wind speed. Default value is set to NULL
#' @return wind value according to the Willoughby model at distance `r` to the
#'  center of the storm located in latitude `lat`

Willoughby_profil = function(w_max, lat, r, rmw = NULL) {
  if (is.null(rmw)) {
    RMW = get_RMW(w_max, lat)
  } else{
    RMW = rmw
  }
  RMW = rep(RMW, length(r))
  if (r >= RMW) {
    XX1 = 287.6 - 1.942 * w_max + 7.799 * log(RMW) + 1.819 * abs(lat)
    XX2 = 25
    AA = 0.5913 + 0.0029 * w_max - 0.1361 * log(RMW) - 0.0042 * abs(lat)
    Wr = w_max * ((1 - AA) * exp(-abs((r - RMW) / XX1)) + AA * exp(-abs(r -
                                                                          RMW) / XX2))
  } else{
    nn = 2.1340 + 0.0077 * w_max - 0.4522 * log(RMW) - 0.0038 * abs(lat)
    Wr = w_max * abs((r / RMW) ^ nn)
  }


  return(Wr)
}

#Vectorize version of the above model
Willoughby <- Vectorize(Willoughby_profil, vectorize.args = "r")



#' Compute wind values according to the Holland 80 model
#'
#' @param r Distance to the center of the storm where the value must be computed
#' @param rmw Radius of maximum wind speed. Default value is set to NULL
#' @param pres Pressure at the center of the storm
#' @param poci Pressure at the Outermost Closed Isobar
#' @param lat Latitude of the eye of the storm
#' @param b Scaling factor
#' @return wind value according to the Holland 80 at distance `r` to the
#'  center of the storm
Holland80_profil = function(r, rmw, pres, poci, lat, b = 1.3){

  r = r
  rmw = rmw
  a = rmw**b
  rho = 1.15 #air densiy
  f = 2 * 7.29 *10**(-5) * sin(lat) #Coriolis parameter

  if(r <= rmw){
    Wr = (a*b*(poci - pres)*exp(-a/r**b)/(rho*r**b))**0.5
  }else{
    Wr = (a*b*(poci - pres)*exp(-a/r**b)/(rho*r**b) + r**2 * f**2 / 4)**0.5 - r*f/2
  }

  return(Wr)

}

#Vectorize version of the above model
Holland80 <- Vectorize(Holland80_profil, vectorize.args = "r")


#' Compute wind values according to the Boose 01 model
#'
#' @param r Distance to the center of the storm where the value must be computed
#' @param t Clockwise angle between forward motion of hurricane and radial line to P
#' @param rmw Radius of maximum wind speed. Default value is set to NULL
#' @param landfall pres Pressure at the center of the storm
#' @param w_max Maximum wind speed generated
#' @param Vh forward speed of storm
#' @param b Scaling factor
#' @return wind value according to the Boose 01 at distance `r` to the
#'  center of the storm
Boose01_profil = function(r, t, rmw, landfall, w_max, Vh, b = 1.3){

  if(landfall > 0){
    f = 1
  }else{
    f = 0.8
  }

  S = 1

 Vs = f *(w_max - S*(1 - sin(t))*Vh/2) * sqrt((rmw/r)**b *exp(1 - (rmw/r)**b))

 return(Vs)

}

#Vectorize version of the above model
Boose01 <- Vectorize(Boose01_profil, vectorize.args = c("r","t"))



#' Rasterizing various products among Maximum sustained Wind Speed and PDI,
#' associated with the each storm
#'
#' @param sts Set of storm generated by `getStorms` we are interested in
#' @param product Characters that represent the product we would like to compute,
#' currently among `MSW` and `PDI`.
#' @param method Cyclonic model used to compute product. Default value is set to
#' `willoughby`.
#' @param asymmetry Logical, whether or not adding asymmetry to the analytic model.
#' Default value is set to TRUE
#' @param use_rmw Logical, whether or not using the Radius of maximum wind speed
#' from the database. Default value is set to TRUE
#' @param space_res Space resolution (km) of the incoming raster products.
#' Default value is set to 10km.
#' @param time_res Time discretization (in hours) to compute the products.
#' Default value is set to 1h.
#' @param verbose Logical, whether or not the function must be verbose. Default
#' value is set to `FALSE`
#' @param focus_loi Logical, whether or not the computations must only take
#' place within the loi. Default
#' value is set to `TRUE`
#'
#' @return A raster stack gathering all the results. Names of the layer are
#' nameOfTheStorm_product
#' @export
stormBehaviour = function(sts,
                          product = "MSW",
                          method = "Willoughby",
                          asymmetry = TRUE,
                          use_rmw = TRUE,
                          space_res = 10,
                          time_res = 1,
                          verbose = FALSE,
                          focus_loi = TRUE) {
  #Check sts input
  stopifnot("no data found" = !missing(sts))

  #Check product input
  stopifnot("Invalid product" = product %in% c("MSW", "PDI", "Category"))

  #Check method input
  stopifnot("Invalid method" = method %in% c("Willoughby", "H80", "Boose01"))

  #Check space_res input
  stopifnot("space_res must be numeric" = identical(class(space_res), "numeric"))
  stopifnot("space_res must be as integer" = is_wholenumber(space_res))
  stopifnot("space_res must be positif" = space_res > 0)

  #Check time_res input
  stopifnot("time_res must be numeric" = identical(class(time_res), "numeric"))
  stopifnot("invalid time_res" = time_res %in% c(1, 0.75, 0.5, 0.25))

  #Check verbose input
  stopifnot("verbose must be logical" = identical(class(verbose), "logical"))

  #Check focus_loi input
  stopifnot("focus_loi must be logical" = identical(class(focus_loi), "logical"))
  initial_floi = focus_loi
  if (product == "PDI") {
    focus_loi = FALSE
    warning("focus_loi ignored for computations")
  }


  #Generating the template
  xmin = sf::st_bbox(sts@spatial.loi.buffer)$xmin
  xmax = sf::st_bbox(sts@spatial.loi.buffer)$xmax
  ymin = sf::st_bbox(sts@spatial.loi.buffer)$ymin
  ymax = sf::st_bbox(sts@spatial.loi.buffer)$ymax
  e <- terra::ext(xmin, xmax, ymin, ymax)

  ras = terra::rast(
    xmin = xmin,
    xmax = xmax,
    ymin = ymin,
    ymax = ymax,
    vals = NA
  )
  #Projection in Mercator
  ras = terra::project(ras, "EPSG:3857")
  #Resample in new resolution in Mercator
  ras.template = ras
  terra::res(ras.template) = space_res * 1000
  ras.template <- terra::resample(ras, ras.template)
  #Reprojection in lon/lat
  ras.template = terra::project(ras.template, "EPSG:4326")
  #Handling time line crossing
  ras.template = terra::crop(ras.template, e)
  ras.template = terra::extend(ras.template, e)


  final.stack = c()
  s = 1

  for (st in sts@data) {
    if (focus_loi) {
      #Use observations within the loi for the computations
      ind = seq(st@obs[1], st@obs[st@numobs], 1)

      #Handling indices and offset (2 outside of loi at entry and exit)
      if (st@obs[1] >= 3) {
        ind = c(st@obs[1] - 2, st@obs[1] - 1, ind)
      } else if (st@obs[1] == 2) {
        ind = c(st@obs[1] - 1, ind)
      }

      if (st@obs[st@numobs] <= st@numobs.all - 2) {
        ind = c(ind, st@obs[st@numobs] + 1, st@obs[st@numobs] + 2)
      } else if (st@obs[st@numobs] == st@numobs.all - 1) {
        ind = c(ind, st@obs[st@numobs] + 1)
      }
    } else{
      #Use all observations available for the computations
      ind = seq(1, st@numobs.all, 1)
    }


    #Get all variables and remove NAs
    dat = data.frame(
      lon = st@obs.all$lon[ind],
      lat = st@obs.all$lat[ind],
      msw = zoo::na.approx(st@obs.all$wind[ind], rule = 2),
      rmw = st@obs.all$rmw[ind],
      roci = st@obs.all$roci[ind],
      pres = st@obs.all$pres[ind],
      poci = st@obs.all$poci[ind],
      landfall = st@obs.all$landfall[ind]
    )
    dat = dat[stats::complete.cases(dat), ]


    #Interpolated time step dt, default value dt = 4 --> 1h
    dt = 1 + (1 / time_res * 3) # + 1 for the limit values

    #Compute number of steps
    last.obs = dim(dat)[1]
    nb.steps = dt * (last.obs - 1) - (last.obs - 2)
    n = 1


    if (verbose) {
      cat("Computing",
          product,
          "raster using",
          method,
          "model (time_res:",
          time_res,
          "h, space_ras:",
          space_res,
          "km, asymmety:",
          asymmetry,
          ", use_rmw:",
          use_rmw,
          ") for",
          st@name,
          "(",
          s,
          "/",
          sts@nb.storms,
          ")\n")
      pb = utils::txtProgressBar(min = 1,
                                 max = last.obs - 1,
                                 style = 3)
    }

    aux.stack = c()
    #For every general 3H time step j
    for (j in 1:(last.obs - 1)) {

      lon = rep(NA, dt)
      lon[1] = dat$lon[j]
      lon[dt] = dat$lon[j + 1]
      lon = zoo::na.approx(lon)

      lat = rep(NA, dt)
      lat[1] = dat$lat[j]
      lat[dt] = dat$lat[j + 1]
      lat = zoo::na.approx(lat)

      wind = rep(NA, dt)
      wind[1] = dat$msw[j]
      wind[dt] = dat$msw[j + 1]
      wind = zoo::na.approx(wind)

      pres = rep(NA, dt)
      pres[1] = dat$pres[j]
      pres[dt] = dat$pres[j + 1]
      pres = zoo::na.approx(pres)

      poci = rep(NA, dt)
      poci[1] = dat$poci[j]
      poci[dt] = dat$poci[j + 1]
      poci = zoo::na.approx(poci)

      rmw = rep(NA, dt)
      rmw[1] = dat$rmw[j]
      rmw[dt] = dat$rmw[j + 1]
      rmw = zoo::na.approx(rmw)

      roci = rep(NA, dt)
      roci[1] = dat$roci[j]
      roci[dt] = dat$roci[j + 1]
      roci = zoo::na.approx(roci)

      landfall = rep(NA, dt)
      landfall[1] = dat$landfall[j]
      landfall[dt] = dat$landfall[j + 1]
      landfall = zoo::na.approx(landfall)



      #Compute velocity of storm (deg/h)
      vx.deg = (dat$lon[j + 1] - dat$lon[j]) / 3
      vy.deg = (dat$lat[j + 1] - dat$lat[j]) / 3
      N = sqrt(vx.deg ** 2 + vy.deg ** 2)

      #(km/h)
      vx.km = vx.deg * space_res / terra::res(ras.template)[1]
      vy.km = vy.deg * space_res / terra::res(ras.template)[2]
      Nv = sqrt(vx.km ** 2 + vy.km ** 2)


      #For every interpolated time steps dt
      for (i in 1:dt) {
        if (i == dt & j != last.obs - 1)
          break #avoid redondance

        raster.msw = ras.template

        #Compute distances to the eye of the storm in m
        dist.m = terra::distance(
          x = terra::crds(raster.msw, na.rm = FALSE)[, ],
          y = cbind(lon[i], lat[i]),
          lonlat = T
        )
        x = (terra::crds(raster.msw, na.rm = FALSE)[, 1] - lon[i])
        y = (terra::crds(raster.msw, na.rm = FALSE)[, 2] - lat[i])
        r = sqrt(x ** 2 + y ** 2) #distance in degree


        #Compute sustained winds according to the input model
        if (method == "Willoughby") {
          if(!use_rmw){
            rmw[i] = NULL
          }
          terra::values(raster.msw) = Willoughby(
            w_max = wind[i],
            lat = lat[i],
            r = dist.m * 0.001,
            rmw = rmw[i]
          )
        }else if (method == "H80") {
          terra::values(raster.msw) = Holland80(
            lat = lat[i],
            r = dist.m * 0.001,
            rmw = rmw[i],
            pres = pres[i],
            poci = poci[i],
            b = 1.05
          )
        }else if (method == "Boose01") {
          raster.t = ras.template
          #South Hemisphere only, t is counterclockwise
          terra::values(raster.t) = acos(x/r)
          terra::values(raster.msw) = Boose01(
            r = dist.m * 0.001,
            t = terra::values(raster.t),
            landfall = landfall[i],
            rmw = rmw[i],
            w_max = wind[i],
            Vh = Nv
          )
        }

        #Add asymmetry
        if (asymmetry) {
          r = sqrt(x ** 2 + y ** 2)
          raster.theta = ras.template
          terra::values(raster.theta) = acos((y * vx.deg+-x * vy.deg) /
                                               (N * r))
          terra::values(raster.msw) = terra::values(raster.msw) +
            cos(terra::values(raster.theta)) * (Nv / 3.6)
        }

        if (product == "Category") {
          r = ras.template
          ind = which(terra::values(raster.msw) >= 32 &
                        terra::values(raster.msw) <= 42)
          r[ind] = 1
          aux.stack = c(aux.stack, r)
          r = ras.template
          ind = which(terra::values(raster.msw) >= 43 &
                        terra::values(raster.msw) <= 49)
          r[ind] = 1
          aux.stack = c(aux.stack, r)
          r = ras.template
          ind = which(terra::values(raster.msw) >= 50 &
                        terra::values(raster.msw) <= 57)
          r[ind] = 1
          aux.stack = c(aux.stack, r)
          r = ras.template
          ind = which(terra::values(raster.msw) >= 58 &
                        terra::values(raster.msw) <= 69)
          r[ind] = 1
          aux.stack = c(aux.stack, r)
          r = ras.template
          ind = which(terra::values(raster.msw) >= 70)
          r[ind] = 1
          aux.stack = c(aux.stack, r)
        } else{
          aux.stack = c(aux.stack, raster.msw)
        }


        if (product == "PDI") {
          Cd = ras.template
          ind1 = terra::values(raster.msw) <= 31.5
          ind2 = terra::values(raster.msw) > 31.5
          terra::values(Cd)[ind1] = (0.8 + 0.06 * terra::values(raster.msw)[ind1]) * 0.001
          terra::values(Cd)[ind2] = (0.55 + 2.97 * (terra::values(raster.msw)[ind2] /31.5)
                                     - 1.49 * (terra::values(raster.msw)[ind2] / 31.5) ** 2) * 0.001
        }

        n = n + 1
      }
      if (verbose)
        utils::setTxtProgressBar(pb, j)
    }

    if (verbose)
      close(pb)

    aux.stack = terra::rast(aux.stack)
    product.raster = ras.template

    if (product == "MSW") {
      #Compute msw raster
      product.raster = max(aux.stack, na.rm = T)
      #Apply focal function twice to smooth results
      product.raster = terra::focal(
        product.raster,
        w = matrix(1, 3, 3),
        max,
        na.rm = T,
        pad = T
      )
      product.raster = terra::focal(
        product.raster,
        w = matrix(1, 3, 3),
        mean,
        na.rm = T,
        pad = T
      )
      names(product.raster) = paste0(st@name, "_", product)
      final.stack = c(final.stack, product.raster)


    } else if (product == "PDI") {
      #Raising to power 3
      aux.stack = aux.stack ^ 3
      #Apply both rho and surface drag coefficient
      rho = 0.001
      aux.stack = aux.stack * rho * Cd
      #Integrating over the whole track
      product.raster = sum(aux.stack, na.rm = T) * time_res
      #Apply focal function to smooth results
      product.raster = terra::focal(
        product.raster,
        w = matrix(1, 3, 3),
        sum,
        na.rm = T,
        pad = T
      )
      names(product.raster) = paste0(st@name, "_", product)
      final.stack = c(final.stack, product.raster)

    } else if (product == "Category") {
      #For each category in SSHS
      ras_c = c()
      for (i in c(1, 2, 3, 4, 0)) {
        ind = which(seq(1, terra::nlyr(aux.stack)) %% 5 == i)
        #Integrating over the whole track
        product.raster = sum(terra::subset(aux.stack, ind), na.rm = T) * time_res
        #Apply focal function to smooth results
        product.raster = terra::focal(
          product.raster,
          w = matrix(1, 3, 3),
          sum,
          na.rm = T,
          pad = T
        )
        if (i == 0)
          i = 5
        names(product.raster) = paste0(st@name, "_", product, i)
        final.stack = c(final.stack, product.raster)
        ras_c = c(ras_c, product.raster)


      }
      #Add all categories
      ras_c = terra::rast(ras_c)
      ras_c = sum(ras_c, na.rm = T)
      names(ras_c) = paste0(st@name, "_Categories")
      final.stack = c(final.stack, ras_c)
    }


    s = s + 1
  }

  final.stack = terra::rast(final.stack)


  if (initial_floi) {
    #Mask the stack to fit loi buffer
    v = terra::vect(sts@spatial.loi.buffer)
    m = terra::rasterize(v, product.raster)
    final.stack = terra::mask(final.stack, m)
  }

  return(final.stack)
}
