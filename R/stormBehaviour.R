



#' Get the radius of maximum wind speed according to Willoughby model
#'
#' @param w_max Maximum wind speed generated
#' @param lat Latitude where `w_max` has occured
#'
#' @return radius of maximum wind speed (km)
get_RMW = function(w_max,lat){
  return (46.4 * exp(-0.0155*w_max + 0.0169*abs(lat)))
}


#' Compute wind values according to the Willoughby model
#'
#' @param w_max Maximum wind speed generated
#' @param lat Latitude where `w_max` has occured
#' @param r Distance to the center of the storm where the value must be computed
#' @param rmw Radius of maximum wind speed. Default value is set to NULL
#' @return wind value according to the Willoughby model at distance `r` to the
#'  center of the storm located in latitude `lat`

Willoughby_cyc_profil = function(w_max, lat, r, rmw = NULL){

  if(is.null(rmw)){
    RMW = get_RMW(w_max,lat)
  }else{
    RMW = rmw
  }
  RMW = rep(RMW,length(r))
  if(r >= RMW){
    XX1 = 287.6 - 1.942 * w_max + 7.799 * log(RMW) +1.819 * abs(lat)
    XX2 = 25
    AA = 0.5913 + 0.0029 * w_max - 0.1361 * log(RMW) -0.0042 * abs(lat)
    Wr = w_max * ((1-AA) * exp(-abs((r-RMW)/XX1)) + AA * exp(-abs(r-RMW)/XX2))
  }else{
    nn = 2.1340 + 0.0077 * w_max - 0.4522 * log(RMW) - 0.0038 * abs(lat)
    Wr = w_max*abs((r/RMW)^nn)
  }


  return(Wr)
}

#Vectorize version of the above model
Willoughby <- Vectorize(Willoughby_cyc_profil, vectorize.args = "r")



#' Rasterizing various products among Maximum sustained Wind Speed and PDI,
#' associated with the each storm
#'
#' @param sts Set of storm generated by `getStorms` we are interested in
#' @param product Characters that represent the product we would like to compute,
#' currently among `MSW` and `PDI`.
#' @param method Cyclonic model used to compute product. Default value is set to
#' `willoughby`.
#' @param use_rmw Logical, whether or not using the Radius of maximum wind speed.
#' from the database. Default value is set to TRUE
#' @param space_res Space resolution (km) of the incoming raster products.
#' Default value is set to 10km.
#' @param time_res Time discretization (in hours) to compute the products.
#' Default value is set to 1h.
#' @param verbose Logical, whether or not the function must be verbose. Default
#' value is set to `FALSE`
#' @param focus_loi Logical, whether or not the computations must only take
#' place within the loi. Default
#' value is set to `TRUE`
#'
#' @return A raster stack gathering all the results. Names of the layer are
#' nameOfTheStorm_product
#' @export
stormBehaviour = function(sts,
                          product = "MSW",
                          method = "willoughby",
                          use_rmw = TRUE,
                          space_res = 10,
                          time_res = 1,
                          verbose = FALSE,
                          focus_loi = TRUE){

  #Check sts input
  stopifnot("no data found" = !missing(sts))

  #Check product input
  stopifnot("Invalid product" = product %in% c("MSW", "PDI", "Category"))

  #Check method input
  stopifnot("Invalid method" = method %in% c("willoughby"))

  #Check space_res input
  stopifnot("space_res must be numeric" = identical(class(space_res),"numeric"))
  stopifnot("space_res must be as integer" = is_wholenumber(space_res))
  stopifnot("space_res must be positif" = space_res > 0)

  #Check time_res input
  stopifnot("time_res must be numeric" = identical(class(time_res),"numeric"))
  stopifnot("time_res must be as integer" = is_wholenumber(time_res))
  stopifnot("time_res must be positif" = time_res > 0)

  #Check verbose input
  stopifnot("verbose must be logical" = identical(class(verbose),"logical"))

  #Check focus_loi input
  stopifnot("focus_loi must be logical" = identical(class(focus_loi),"logical"))
  if(product == "PDI"){
    focus_loi = FALSE
    warning("focus_loi ignored and set to FALSE")
  }


  xmin = sf::st_bbox(sts@spatial.loi.buffer)$xmin
  xmax = sf::st_bbox(sts@spatial.loi.buffer)$xmax
  ymin = sf::st_bbox(sts@spatial.loi.buffer)$ymin
  ymax = sf::st_bbox(sts@spatial.loi.buffer)$ymax
  e <- terra::ext(xmin, xmax, ymin, ymax)

  ras = terra::rast(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax, vals=NA)
  #Projection in Mercator
  ras = terra::project(ras,"EPSG:3857")
  #Resample in new resolution in Mercator
  ras.template = ras
  terra::res(ras.template) = space_res*1000
  ras.template <- terra::resample(ras,ras.template)
  #Reprojection in lon/lat
  ras.template = terra::project(ras.template,"EPSG:4326")
  #Handling time line crossing
  ras.template = terra::crop(ras.template, e)
  ras.template = terra::extend(ras.template,e)


  product.stack = c()
  s = 1

  for(st in sts@data){

    product.raster = ras.template

    if(all(!is.na(st@obs.all$wind)))
      warning("NA values detected")


    if(focus_loi){
      #Handling indices and offset
      ind = seq(st@obs[1],st@obs[st@numobs],1)

      if(st@obs[1] >= 3){
        ind = c(st@obs[1] - 2,st@obs[1] - 1, ind)
      }else if(st@obs[1] == 2){
        ind = c(st@obs[1] - 1, ind)
      }

      if(st@obs[st@numobs] <= st@numobs.all - 2){
        ind = c(ind, st@obs[st@numobs] + 1, st@obs[st@numobs] + 2)
      }else if(st@obs[st@numobs] == st@numobs.all - 1){
        ind = c(ind, st@obs[st@numobs] + 1)
      }
    }else{
      ind = seq(1,st@numobs.all,1)
    }

    #Get all variables
    lon = st@obs.all$lon[ind]
    lat = st@obs.all$lat[ind]
    msw = zoo::na.approx(st@obs.all$wind[ind],rule = 2)
    if(use_rmw)
      rmw = st@obs.all$rmw[ind]

    #Compute number of steps
    last.obs = length(ind)
    nb.steps = 4*(last.obs-1) - (last.obs-2)
    n = 1
    aux.stack = c()

    if(verbose){
      cat(st@name,"-",product,"(",s,"/",sts@nb.storms,")\n")
      pb = utils::txtProgressBar(min = 1,
                                 max = last.obs-1,
                                 style = 3)
    }

    #For every general 3H time step j
    for(j in 1:(last.obs-1)){

        #Interpolated time step dt, default value dt = 1*3 --> 1h
        dt = 1 + (time_res * 3) #+ 1 for the limit values
        longitude = rep(NA,dt);
        longitude[1] = lon[j];
        longitude[dt] = lon[j+1];
        longitude = zoo::na.approx(longitude)

        latitude = rep(NA,dt)
        latitude[1] = lat[j]
        latitude[dt] = lat[j+1]
        latitude = zoo::na.approx(latitude)

        wind = rep(NA,dt)
        wind[1] = msw[j]
        wind[dt] = msw[j+1]
        wind= zoo::na.approx(wind)

        if(use_rmw){
          radius = rep(NA,dt)
          radius[1] = rmw[j]
          radius[dt] = rmw[j+1]
          radius = zoo::na.approx(radius)
        }else{
          radius = NULL
        }

        #For every interpolated time steps dt
        for(i in 1:dt){

          if(i == dt & j != last.obs-1)
            break #avoid redondance

          raster.msw = product.raster
          # distances to the eye of the storm in km
          dist.km = terra::distance(x = terra::crds(raster.msw, na.rm = FALSE)[,],
                                    y = cbind(longitude[i],latitude[i]),
                                    lonlat = T) * 0.001

          if(method == "willoughby"){
            #Compute willoughby raster
            terra::values(raster.msw) = Willoughby(w_max = wind[i],
                                                   lat = latitude[i],
                                                   r = dist.km,
                                                   rmw = radius[i])
          }

          if(product == "Category"){
            r = product.raster
            ind = which(terra::values(raster.msw) >= 32 & terra::values(raster.msw) <= 42)
            r[ind] = 1
            aux.stack = c(aux.stack,r)
            r = product.raster
            ind = which(terra::values(raster.msw) >= 43 & terra::values(raster.msw) <= 49)
            r[ind] = 1
            aux.stack = c(aux.stack,r)
            r = product.raster
            ind = which(terra::values(raster.msw) >= 50 & terra::values(raster.msw) <= 57)
            r[ind] = 1
            aux.stack = c(aux.stack,r)
            r = product.raster
            ind = which(terra::values(raster.msw) >= 58 & terra::values(raster.msw) <= 69)
            r[ind] = 1
            aux.stack = c(aux.stack,r)
            r = product.raster
            ind = which(terra::values(raster.msw) >= 70)
            r[ind] = 1
            aux.stack = c(aux.stack,r)
          }else{
            aux.stack = c(aux.stack,raster.msw)
          }

          n = n+1
        }
        if(verbose)
          utils::setTxtProgressBar(pb, j)
    }

    if(verbose)
      close(pb)

    aux.stack = terra::rast(aux.stack)
    if(product == "MSW"){
      #Compute msw raster
      product.raster = max(aux.stack, na.rm = T)
      #Apply focal function twice to smooth results
      product.raster = terra::focal(product.raster, w=matrix(1,3,3), max, na.rm = T, pad=T)
      product.raster = terra::focal(product.raster, w=matrix(1,3,3), mean, na.rm = T, pad=T)
      names(product.raster) = paste0(st@name,"_",product)
      product.stack = c(product.stack, product.raster)
    }else if(product == "PDI"){
      #Raising to power 3
      aux.stack = aux.stack^3
      #Apply surface drag coefficient
      aux.stack = aux.stack * 0.001
      #Integrating over the whole track
      product.raster = sum(aux.stack, na.rm = T)
      #Apply focal function to smooth results
      product.raster = terra::focal(product.raster, w=matrix(1,3,3), sum, na.rm = T, pad=T)
      names(product.raster) = paste0(st@name,"_",product)
      product.stack = c(product.stack, product.raster)
    }else if(product == "Category"){
      #Compute Category 1 raster
      for(i in c(1,2,3,4,0)){
        ind = which(seq(1,terra::nlyr(aux.stack)) %% 5 == i)
        product.raster = sum(terra::subset(aux.stack,ind), na.rm = T)
        #Apply focal function to smooth results
        product.raster = terra::focal(product.raster, w=matrix(1,3,3), sum, na.rm = T, pad=T)
        if(i == 0)
          i = 5
        names(product.raster) = paste0(st@name,"_",product,i)
        product.stack = c(product.stack, product.raster)
      }
    }

    product.stack = terra::rast(product.stack)
    if(focus_loi){
      v = terra::vect(sts@spatial.loi.buffer)
      m = terra::rasterize(v,product.raster)
      product. = terra::mask(unlist(product.stack),m)
    }

    s = s+1
  }

  return(terra::rast(product.stack))
}





